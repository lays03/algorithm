# 1. 冒泡排序
## 1.1 冒泡排序的优化
在第二层循环外加一个flag，判断还没进行判断的子序列是否为有序
```cpp
//冒泡排序
void mySort::BubbleSort(vector<int>& v, int n)
{
    //时间复杂度(平均): O(n^2)
    //空间复杂度(额外): 在swap创建过临时变量 O(1)
    //稳定性: 稳定
    for(int i = 0; i < n - 1; ++i)
    {
        bool flag = true; //假设已经有序了
        for(int j = 0; j < n - i - 1; ++j)
        {
            if(v[j] > v[j + 1])
            {
                swap(v[j], v[j+1]);
                flag = false; //表示当前序列还是无序的
            }
        }
        //flag = true, 说明已经有序了 不用再继续判断了
        if(flag) break;
    }
}
```

# 2. 选择排序
冒泡排序的改进
```cpp
//选择排序
void mySort::SelectSort(vector<int>& v, int n)
{
    //时间复杂度(平均): O(n^2)
    //空间复杂度(额外): 在swap创建过临时变量 O(1)
    //稳定性: 不稳定
    for(int i = 0; i < n; ++i)
    {
        int max = i;
        for(int j = i + 1; j < n; ++j)
        {
            if(v[max] < v[j])
            {
                max = j;
            }
        }
        if(max != i)
        {
            swap(v[max], v[i]);
        }
    }
}
```


# 3. 插入排序
- 首先构建有序区
- 然后把无序区的元素放到有序区
```cpp
//直接插入排序
void mySort::InsertSort(vector<int>& v, int n)
{
    //时间复杂度(平均): O(n^2)
    //空间复杂度(额外): O(1)
    //稳定性: 稳定
    for(int j = 1; j < n; ++j) //构造无序区
    {
        for(int i = 0; i <= j - 1; ++i) //构造有序区
        {
            if(v[j] < v[i]) //讨论时间复杂度的时候, 不是每次都是执行的, 因此是有穷的
            {
                //下面两种后移方式都可以
                int index1 = i;
                int index2 = j;
                int temp = v[j];
                while(i < j)
                {
                    v[index2] = v[index2 - 1];
                    i++;
                    index2--;
                }
                v[index1] = temp;

                // int temp = v[j];
                // for(int k = j - 1; k >= i; k--)
                // {
                //     v[k + 1] = v[k];
                // }
                // v[i] = temp;
                // break;
            }
        }
    }
}
```

# 4. 希尔排序(缩小增量排序)
希尔排序是插入排序的改进

本质上是一种分组插入方法。基本思想：对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap倍数的记录放在同一个组中；然后对各组内的元素进行直接插入排序。这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap = 1时，整个数列就是有序的。







